저희 조가 구현한 부분은 쉬프트부분을 추가구현했습니다.


산술 시프트: 부호화된 2의 보수의 규칙에 따라 시프트 되며 , 오른쪽 시프트 일때는 가장 왼쪽의
부호 비트의 값은 그대로 나두고 그다음부터 오른쪽으로 시프트 처리한다.,
왼쪽 시프트 일때는 부호 비트를 잃어 버리고 0을 끝 위치에 넣어 준다.

논리 시프트: 0를 오른쪽 시프트 때에는 왼쪽 맨 끝에, 왼쪽 시프트 일때는 오른쪽 끝에 넣어줌

회전시프트는 시프트되어 나간 비트는 그 값을 잃어 버리지 않고 다른 한끝으로 들어 오게 된다

///////////////////////////////////////////////////////////////////////////////////////////////

산술시프트의 왼쪽시프트 동작을 하는 ASL은 한칸씩 왼쪽으로 시프트를 하고 부호 비트를 잃어버리고 0을 LSB에 넣어주는 동작을 합니다.
그리고 산술시프트의 오른쪽시프트 동작을 하는 ASR은 가장 왼쪽의 부호비트 즉, MSB는 그대로 유지하고 그 다음부터 오른쪽으로 한칸씩 시프트하는 동작을 합니다.
그래서 이를 코드로 구현한것을 보시면 Mux를 사용해 LorR에 따라 왼쪽으로 시프트를 할건지 오른쪽으로 시프트를 할건지를 정하게 됩니다.
LorR=0일 경우 왼쪽 시프트를 하게 되어서 입력 a가 출력 out으로 선택되어 나가게됩니다.
이때 out[0]으로는 0을 넣어주도록하고, 나머지는 in[0]이 out[1]로, in[1]이 out[2]로, in[2]가 out[3]으로
이런식으로 왼쪽시프트 동작을 하게 됩니다.
산술시프트의 오른쪽시프트 동작을 하는 ASR은 가장 왼쪽 부호 비트 즉, MSB는 그대로 유지하기위해 in[15]가 out[15]로 선택되고,
나머지부분들은 in[1]이 out[0]으로, in[2]가 out[1]로 이런식으로 오른쪽 시프트 동작을 하도록 했습니다.

논리시프트의 왼쪽시프트 동작은 산술시프트의 왼쪽시프트 동작과 동일하고, 논리시프트의 오른쪽시프트 동작은 0을 MSB에 넣어주고 오른쪽으로 한칸씩 시프트하는
동작을 합니다. 논리시프트의 왼쪽시프트 동작인 LSL은 산술시프트의 왼쪽시프트와 동작이 같으므로 생략하도록 하고, 오른쪽시프트의 경우는
한칸씩 오른쪽시프트를 하도록 하고 out[15]에 0을 넣어주는 작업을 하도록하여 논리시프트칩을 구현했습니다.

회전시프트의 경우에는 시프트되어 나간 비트는 그 값을 잃어버리지않고 다른 한 끝으로 들어오게 하는 동작을 합니다.
그래서 왼쪽시프트의 경우에는 MSB가 LSB로 가도록하게하기위해 in[15]이 out[0]로 출력되게 하고 나머지는 왼쪽으로 한칸씩 시프트하도록했습니다.
오른쪽시프트의 경우에는 LSB가 MSB로 가도록하기위해 in[0]이 out[15]로 출력되게 하고 나머지는 오른쪽으로 한칸씩 시프트하도록 구현했습니다.

캐리와 함께 회전시프트의 경우 findcarry 칩을 추가로 구현하여 두 입력에 대한 carry를 받아오도록 했습니다. 이때 halfadder와 fulladder를 이용하여 구현했습니다.
그래서 Cshift 칩에서는 findcarry로부터 carry를 받아와서 carry가 0이면 왼쪽시프트 동작을 하도록하고, carry가 1이면 오른쪽 시프트 동작을 하도록 구현했으며,
마지막에 왼쪽시프트의 경우 carry에 MSB가 저장되도록하고, 오른쪽시프트의 경우 carry에 LSB가 저장되도록 하는 코드를 Mux와 Bit칩을 이용해 구현했습니다.



산술 시프트: 
-왼쪽: 부호 비트를 잃어버리고 0을 LSB에 넣어준다.
-오른쪽: 가장 왼쪽의 부호비트 즉, MSB는 그대로 유지하고 그다음부터 오른쪽으로 한칸씩 시프트

논리시프트:
-오른쪽 시프트일때는 0을 LSB에, 왼쪽시프트일때는 0을 MSB에 넣어준다.
+) ASL, LSL은 동작 같음

회전시프트:
- 시프트되어 나간 비트는 그 값을 잃어버리지않고 다른 한 끝으로 들어오게 된다.

캐리와 함께 회전 시프트:
- 왼쪽: carry가 0이면 왼쪽시프트. carry가 LSB로 가고 MSB 비트가 carry로 저장됨
- 오른쪽: carry가 1이면 오른쪽시프트. carry가 MSB로 가고 LSB가 carry로 저장됨

+) 16비트 연산이라고 하면 32비트에 대해 회전시프트를 수행하고싶다면, 캐리와 함께 회전시프트를
 사용. 즉 carry비트로 넘어간게 하위 16비트, 상위 16비트에서 고려되어야할 때 사용한다.


+) 회전을 통한 캐리는 프로세서의 기본 워드 크기 보다 큰 숫자에 대해 시프트를 수행할 때 특히 유용 합니다. 
큰 숫자가 두 레지스터에 저장되어 있는 경우 첫 번째 레지스터의 한쪽 끝에서 쉬프트된 비트가 
다른 쪽 끝에 들어와야 하기 때문입니다. 두번째, 회전을 통한 캐리를 사용하면 해당 비트가 
첫 번째 시프트 동안 캐리 플래그에 "저장"되어 추가 준비 없이 두 번째 시프트 동안 시프트할 준비가 됩니다.

+) 캐리 플래그에 0이 포함되어있으면 논리 오른쪽시프트이고, 캐리 플래그에 부호비트 복사본이
포함되어 있으면 산술 오른쪽 시프트이다.


